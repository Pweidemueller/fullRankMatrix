---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fullRankMatrix

<!-- badges: start -->
<!-- badges: end -->

The goal of fullRankMatrix is to remove empty columns (contain only 0's), merge duplicated columns and merge linearly dependent columns. These operations will create a matrix of full rank. The changes made to the columns are reflected in the column headers interpretability if the matrix is used in e.g. a linear model fit.

## Installation

You can install the development version of fullRankMatrix from [GitHub](https://github.com/) with:

```r
# install.packages("devtools")
devtools::install_github("Pweidemueller/fullRankMatrix")
```

## Example

When using linear models you should check if any of the columns in your model matrix are linearly dependent. If they are this will alter the interpretation of the model fit. Here is a very constructed example where we are interested in identifying the factors that make fruit sweet. We can classify fruit into what fruit they are and also at what season they are harvested. 
```{r}
library(fullRankMatrix)
# let's say we have 10 fruits and can classify them into strawberries, apples or pears
# in addition we classify them by the season they are harvested in
strawberry <- c(1,1,1,1,0,0,0,0,0,0)
apple <- c(0,0,0,0,1,1,1,0,0,0)
pear <- c(0,0,0,0,0,0,0,1,1,1)
spring <- c(1,1,0,0,0,0,0,0,0,0)
summer <- c(1,1,1,1,1,1,1,0,0,0)
fall <- c(0,0,0,0,0,0,1,1,1,1)

# let's pretend we know how each factor influences the sweetness of a fruit
strawberry_sweet <- strawberry * rnorm(10, 4)
apple_sweet <- apple * rnorm(10, 1)
pear_sweet <- pear * rnorm(10, 0.5)
spring_sweet <- spring * rnorm(10, 2)
summer_sweet <- summer * rnorm(10, 5)
fall_sweet <- fall * rnorm(10, 1)

sweetness <- strawberry_sweet + apple_sweet + pear_sweet +
  spring_sweet + summer_sweet + fall_sweet

mat <- as.matrix(data.frame(strawberry,apple,pear,spring,summer,fall))

fit <- lm(sweetness ~ mat + 0)
print(summary(fit))
```
As you can see `lm` realizes that there are linearly dependent columns (`matsummer` is not defined) but it doesn't indicate what columns it is linearly dependent with.

So if you would just look at the coefficients and not consider the `NA` further, you would interpret that `strawberry`, `apple` and `spring` make fruit sweet.

However, when you look at the model matrix you can see that `summer` is a linear combination of `strawberry` and `apple`. So truly any of the three factors could contribute to the sweetness of a fruit, the linear model has no way of recovering which one given these 10 examples. 

To make such cases more obvious we wrote `fullRankMatrix`, it removes linearly dependent columns and renames the remaining columns to make the dependencies clear.

```{r}
mat_fullrank <- make_full_rank_matrix(mat)
fit <- lm(sweetness ~ mat_fullrank + 0)
print(summary(fit))
```
You can see that there are no more undefined coefficients, since the coefficient `summer` was removed. Coefficient `strawberry` was renamed to indicate that either `strawberry` could make the fruit sweet or it could be a combination of `apple` in `summer` (`strawberry_OR_(summer_COMB_apple)`). Vice versa `apple` was renamed to `apple_OR_(summer_COMB_strawberry)` to indicate this dependency.
