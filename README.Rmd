---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fullRankMatrix

<!-- badges: start -->
<!-- badges: end -->

We developed `fullRankMatrix` primarily for one-hot encoded design matrices used in linear models. Especially for large one-hot encoded design matrices, the chances of having linearly dependent columns is high which will hinder interpretation of association between independent and dependent variables in the linear model (see example below).

The goal of `fullRankMatrix` is to remove empty columns (contain only 0's), merge duplicated columns (containing the same entries) and merge linearly dependent columns. These operations will create a matrix of full rank. The changes made to the columns are reflected in the column headers such that the columns can still be interpreted if the matrix is used in e.g. a linear model fit.

## Installation

You can install the development version of `fullRankMatrix` from [GitHub](https://github.com/) with:

```r
# install.packages("devtools")
devtools::install_github("Pweidemueller/fullRankMatrix")
```

## Example

When using linear models you should check if any of the columns in your model matrix are linearly dependent. If there are, this will alter the interpretation of the model fit. Here is a rather constructed example where we are interested in identifying the factors that make fruit sweet. We can classify fruit into what fruit type they are and also at what season they were harvested in. 
```{r}
# let's say we have 10 fruits and can classify them into strawberries, apples or pears
# in addition we classify them by the season they were harvested in
strawberry <- c(1,1,1,1,0,0,0,0,0,0)
apple <- c(0,0,0,0,1,1,1,0,0,0)
pear <- c(0,0,0,1,0,0,0,1,1,1)
spring <- c(1,1,0,0,0,0,0,0,0,0)
summer <- c(1,1,1,1,1,1,1,0,0,0)
fall <- c(0,0,0,0,0,0,1,1,1,1)

# let's pretend we know how each factor influences the sweetness of a fruit
# in this case we say that strawberry and summer have the biggest influence on sweetness
strawberry_sweet <- strawberry * rnorm(10, 4)
apple_sweet <- apple * rnorm(10, 1)
pear_sweet <- pear * rnorm(10, 0.5)
spring_sweet <- spring * rnorm(10, 2)
summer_sweet <- summer * rnorm(10, 5)
fall_sweet <- fall * rnorm(10, 1)

sweetness <- strawberry_sweet + apple_sweet + pear_sweet +
  spring_sweet + summer_sweet + fall_sweet

mat <- as.matrix(data.frame(strawberry,apple,pear,spring,summer,fall))

fit <- lm(sweetness ~ mat + 0)
print(summary(fit))
```
As you can see `lm` realizes that there are linearly dependent columns (`matsummer` is not defined) but it doesn't indicate what columns it is linearly dependent with.

So if you would just look at the columns and not consider the `NA` further, you would interpret that `strawberry` and `apple` make fruit sweet.

However, when you look at the model matrix you can see that the `summer` column is a linear combination of the `strawberry` and `apple` columns (or vice versa). So truly any of the three factors could contribute to the sweetness of a fruit, the linear model has no way of recovering which one given these 10 examples. 
```{r}
mat
```
To make such cases more obvious and retain interpretability of the linear model fit we wrote `fullRankMatrix`, it removes linearly dependent columns and renames the remaining columns to make the dependencies clear using the `make_full_rank_matrix()` function.

```{r}
library(fullRankMatrix)
result <- make_full_rank_matrix(mat)
mat_fr <- result$matrix
space_list <- result$space_list
mat_fr
```

```{r}
fit <- lm(sweetness ~ mat_fr + 0)
print(summary(fit))
```
You can see that there are no more undefined columns. The columns `strawberry`, `apple` and `summer` were removed and replaced with two columns (`SPACE_1_AXIS1`, `SPACE_1_AXIS2`) that are linearly independent (orthogonal) vectors that span the space previously spanned by the linearly dependent columns `strawberry`, `apple` and `summer`. The original columns that are contained with a space can be viewed in the returned `space_list`:
```{r}
space_list
```

In terms of interpretation the individual axes of the space have no meaning, but seeing that the space of `strawberry`, `apple` and `summer` show a significant association with the sweetness of fruit. A further resolution which of the three variables is most strongly associated with `sweetness` is not possible with the given number of observations, but there is definitely an association of `sweetness` with the space spanned by the three variables.

### Other available packages that detect linear dependent columns
There are already a few other packages out there that offer functions to detect linear dependent columns. Here are the ones we are aware of:

**`caret::findLinearCombos()`**: https://rdrr.io/cran/caret/man/findLinearCombos.html

This function identifies which columns are linearly dependent and suggests which columns to remove. But it doesn't provide appropriate naming for the remaining columns to indicate that any significant associations with the remaining columns is actually an association with the space spanned by the originally linearly dependent columns. Just removing the 5th column (`summer`) and then fitting the linear model would lead to erroneous interpretation.
```{r}
caret_result <- caret::findLinearCombos(mat)
```
Fitting a linear model with the 5th column (`summer`) removed would lead to erroneous interpretation that `strawberry` and `apple` influence the `sweetness`, but we know it is actually `strawberry` and `summer`.
```{r}
mat_caret <- mat[, -caret_result$remove]
fit <- lm(sweetness ~ mat_caret + 0)
print(summary(fit))
```


**`WeightIt::make_full_rank()`**: https://rdrr.io/cran/WeightIt/man/make_full_rank.html

This function removes some of the linearly dependent columns to create a full rank matrix, but doesn't rename the remaining columns accordingly. For the user it isn't clear which columns were linearly dependent and they can't choose which column will be removed.
```{r}
mat_weightit <- WeightIt::make_full_rank(mat, with.intercept = FALSE)
mat_weightit
```
As above fitting a linear model with this full rank matrix would lead to erroneous interpretation that `strawberry` and `apple` influence the `sweetness`, but we know it is actually `strawberry` and `summer`.

```{r}
fit <- lm(sweetness ~ mat_weightit + 0)
print(summary(fit))
```


**`plm::detect.lindep()`:** https://rdrr.io/cran/plm/man/detect.lindep.html

The function returns which columns are potentially linearly dependent.
```{r}
plm::detect.lindep(mat)
```

However it doesn't capture all cases. For example here `plm::detect.lindep()` says there are no dependent columns, while there are several:
```{r}
c1 <- rbinom(10, 1, .4)
c2 <- 1-c1
c3 <- integer(10)
c4 <- c1
c5 <- 2*c2
c6 <- rbinom(10, 1, .8)
c7 <- c5+c6
mat_test <- as.matrix(data.frame(c1,c2,c3,c4,c5,c6,c7))

plm::detect.lindep(mat_test)
```

`fullRankMatrix` captures these cases:
```{r}
result <- make_full_rank_matrix(mat_test)
result$matrix
```
**`Smisc::findDepMat()`**: https://rdrr.io/cran/Smisc/man/findDepMat.html

**NOTE**: this package was removed from CRAN as of 2020-01-26 (https://cran.r-project.org/web/packages/Smisc/index.html) due to failing checks.

This function indicates linearly dependent rows/columns, but it doesn't state which rows/columns are linearly dependent with each other.

However, this function seems to not work well for one-hot encoded matrices and the package doesn't seem to be updated anymore (s. this issue: https://github.com/pnnl/Smisc/issues/24).
```
# example provided by Smisc documentation
Y <- matrix(c(1, 3, 4,
              2, 6, 8,
              7, 2, 9,
              4, 1, 7,
              3.5, 1, 4.5), byrow = TRUE, ncol = 3)
Smisc::findDepMat(t(Y), rows = FALSE)
```

Trying with the model matrix from our example above:
```
Smisc::findDepMat(mat, rows=FALSE)
#> Error in if (!depends[j]) { : missing value where TRUE/FALSE needed
```

